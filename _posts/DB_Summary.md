## Database System Concepts Summary



## Chapter 1

- DBMS 는 서로관계있는 데이터의 모음과 그러한 데이터에 접근하는 프로그램의 모음으로 구성되어 있습니다.  
  데이터는 하나의 특정한 enterprise 를 말합니다.   
- DBMS 의 목표는 편하고 효율적인 환경을 제공하는 것입니다.
- 디비 시스템은 큰 규모의 정보를 저장하도록 고안되었습니다.  
  데이터의 관리는 정보의 스토리지에 대한 구조의 정의와 정보 조작에 대한 매커니즘 조항 둘 다 포함합니다.  
  추가적으로 데이터베이스 시스템은 정보에 대한 안전성을 제공합니다. - 시스템 crash 나 접근 등,  
  만약 데이터가 여러 사용자들에게 공유되는 경우 익명적인 결과가 발생하는 것을 피해야 한다.  
- 데이터 베이스 시스템의 메인 목적은 사용자에게 데이터의 abstract view 를 제공하는 것 입니다.  
  시스템은 어떻게 데이터가 저장되고 유지되는지에 대한 세부사항은 숨깁니다.  
- 데이터 베이스 구조의 기초는 데이터 모델입니다.  
  데이터를 표현하기 위한 개념적인 툴들과 데이터 관계, 데이터 semantic, 그리고 data constrains d의 모음입니다.
- 관계적 데이터 모델은 데이터를 저장하기 위해 가장 널리 사용되는 모델입니다.  
  다른 데이터 모델은 object-oriented, object-relational, semi-structure 모델이 있습니다.
- 데이터 조작 언어(data-manipulation language,DML)은 사용자에게 데이터를 조작하도록 할 수 있게 하는 언어입니다.  
  비절자적, Nonprecedual DML 은 사용자에게 어떤 데이터가 필요한지만 명시하도록 요청합니다.  
  이러한 데이터를 구체적으로 어떻게 가져올지는 요청하지 않습니다.  
  오늘날 대부분 사용되는 DML 입니다. 
- DDL(data-definition language) 는 데이터 베이스 스키마와 데이터의 다른 속성을 명시하기 위해 사용되는 언어입니다.
- 데이터베이스 설계는 주로 데이터베이스 스키마의 설계를 포함합니다.  
  entity-relationship (E-R) 데이터 모델은 데이터 베이스 설계를 위해 주로 사용되는 모델입니다.  
  이것은 데이터와 관계, 제약들을 보기 위한 시각적인 표현을 제공합니다.  
- 데이터베이스 시스템은 여러 subsystem을 갖고 있습니다.
  - Storage manger subsystem 은 데이터 베이스에 저장되어 있는 저레벨 데이터와 어플리케이션 프로그램 사이의 인터페이스를 제공하고, 시스템에 쿼리를 제출합니다.
  - query processor subsytem 은 DDL과 DML statement 들을 컴파일하고 실행합니다.
- Transaction management 은 데이터베이스가 시스템 오류에서도 지속적인 상태로 유지하는 것을 보장합니다.  
  trasaction manager 는 충돌없이 동시에 transaction 실행하는 것을 보장합니다.
- 데이터 베이스 시스템 아키텍처는 수행되는 컴퓨터 시스템에 큰 영향을 받습니다.   
  데이터 베이스 시스템은 다중 머신을 포함하여 centralized 되거나 병렬화될 수 있습니다.  
  분산 데이터베이스는 다중의 물리적 분리된 머신들까지 확장합니다.
- 데이터베이스 응용 프로그램은 일반적으로 클라이언트 컴퓨터에서 실행되는 프런트 엔드 부분과 백엔드에서 실행되는 부분으로 나뉩니다.  
  2 티어 아키텍처에서, 프론트앤드는 직접적으로 벡엔드에서 실행중인 데이터 베이스와 통신합니다.  
  3 티어 아키텍처에서는, 벡엔드 부분은 application server 와 database server 로 나눠집니다.
- 네 가지 유형의 데이터베이스 시스템 사용자가 있으며 시스템과 상호 작용할 것으로 예상되는 방식이 다릅니다. 다양한 유형의 사용자를 위해 다양한 유형의 사용자 인터페이스가 설계되었습니다.
- 데이터 분석 기술은 자동적으로 데이터로 부터 규칙과 패턴을 찾는 것을 시도합니다.  
  데이터 마이닝 분야는 인공 지능 연구자와 통계 분석가가 발명 한 knowledge discovery 기술과 이를 매우 큰 데이터베이스에서 사용할 수있는 효율적인 구현 기술을 결합합니다.



## Chapter 2

- 관계 데이터 모델은 테이블의 모음에 기반합니다.  
  디비 시스템의 사용자는 이러한 테이블에 대해 쿼리를하고, 튜플을 삽입하고, 지우고 수정합니다.  
  이러한 연산들을 표현하는 여러 언어들이 있습니다.
- 관계의 스키마는 논리적 설계를 참조하는 반면 관계의 인스턴스는 특정 시점의 내용을 참조합니다.  
  데이터베이스의 스키마와 인스턴슨느 유사하게 정의 됩니다.  
  스키마는 그것의 attribute 와 부가적으로 attribute 의 타입, 관계의 제약(foreign-key 같은) 을 포함합니다. 
- 릴레이션의 슈퍼키는 하나 혹은 그 이상의 attribute 의 집합입니다. - 이것의 값들은 릴레이션에서 투플들을 유니크하게 표현하는것을(identify) 보장합니다.  
  후보키는 최소한의 슈퍼키 입니다.  이것은 attribute 의 집합이고, 이로 슈퍼키를 형성할 수 있지만, 이것의 부분집합 중 어느것도 슈퍼키가 될 수 없는 것 입니다.  
  한 릴레이션의 후보키들 중 하나는 반드시 primary key 로 선택되어야 합니다.
- 릴레이션 $r_1$ 의 attribute A 부터 $r_2$ 의 primary-key B 로의 foreign-key 제약 은  
  $r_1$ 에 있는 각 튜플의  A 값이 반드시 $r_2$ 의 어떤 튜플 에 대한 B 값이 되어야 한다는 것입니다.  
  릴레이션 $r_1$ 은 referncing relation 이라고 하고  
  릴레이션 $r_2$ 는 referenced relation 이라 합니다.
- 스키마 다이어그램은 데이터베이스의 관계, attrubiute , primary key, foreign key 를 보여주는 데이터베이스 스키마의 그림 묘사입니다.
- relational query language 는 테이블에서 작동하는 연산과 그것의 결과로써의 output 테이블의 집합으로 정의합니다.  
  이러한 작업을 결합하여 원하는 쿼리를 표현하는 식을 얻을 수 있습니다.
- relational algebra 는 하나 이상의 relation 를 입력으로 사용하고 relation 을 출력으로 반환하는 연산의 집합을 제공합니다.   
  SQL과 같은 실용적인 쿼리 언어는 relational algebra 를 기반으로하고 몇가지  유용한 구문 기능을 많이 추가하였습니다.
- relational algebra 는 테이블에서 작동하는 대수 연산의 집합을 정의하고 그 결과로 테이블을 출력합니다.   
  이러한 연산을 결합하여 원하는 쿼리를 표현하는 표현식을 얻을 수 있습니다.   
  대수는 SQL과 같은 relational query language 에서 사용되는 기본 연산을 정의합니다. 



## Chapter 3

- SQL 은 가장 여러 파트를 갖습니다.
  - Data-definition Language(DDL) : 릴레이션 스키마를 정의하거나 릴레이션을 삭제, 스키마를 수정하기 위한 명령어를 제공합니다. 
  - Data-manipulation Language(DML) : 쿼리 언어와 튜플을 삽입, 삭제, 수정하는 명령어를 포함합니다. 
- SQL DDL 은 명시된 스키마들을 가진 릴레이션들을 만들기 위해 사용됩니다.  
- 부가적으로 릴레이션 attribute 의 이름과 타임을 명시하면서 SQL 은 integrity 제약 (primary, foreingn-key constraints) 을 명시할 수 있습니다.
- SQL은 어트리뷰트와 릴레이션 모두 리네임 할 수 있느느 매커니즘을 제공합니다. 그리고 쿼리의 결과가 명시된 어트리뷰트로 정렬되도록 명령할 수 있습니다.  
- SQL 은 릴레이션의 기본적인 집합 연산을 지원합니다.   
  union, intersection, except 을 포함합니다. ($\cup, \cap, -$)
- SQL 은 릴레이션은 null 값을 포함하는 릴레이션을 다룹니다. - 이는 T/F 의 진리 값(truth value)에  진리 값 'unknown' 을 추가하여 다룹니다.
- SQL 은 aggregation 을 지원합니다. -릴레이션을 그룹들로 나누는 능력을 포함하여, 각 그룹에서 분리적으로 aggregation 을 지원합니다.  
  SQL 은 그룹에 대한 집합 연산을 지원합니다.
- SQL 은 nested subqueries 를 지원합니다. outer query 의 where 와 from 절에서 사용할 수 있습니다.  
  이는 또한 scalar subqueries 를 지원합니다.- 한 expression 이 리턴한 값을 사용할 수 있습니다.
- SQL 은 업데이터, 삽입, 삭제하는 정보에 대한 구성을 지원합니다.



## Chapter 4

- SQL 은 여러 종류의 natural join, inner outer join 과 여러 종류의 join conditnion 들을 지원합니다.  

  - Natural join 은 where 술어가 각 릴레이션에서 일치하는 이름과 어트리뷰트를 동일시하는 여러 릴레이션에 대한 쿼리를 작성하는 간단한 방법을 제공합니다.(동일한 이름을 가지고 하는 것)   
    이는 스키마에 새 어트리뷰트가 추가되면 쿼리 의미가 변경 될 위험이 있습니다.

    **select** *name*, *title*

    **from** *student* **natural join** *takes* **natural join** *course*

  - join-using 구문은 이름이 일치하는 모든 어트리뷰트에 대해 동일성이 요구되는 여러 관계에 대한 쿼리를 작성하는 간단한 방법을 제공합니다.

    **select** *name*, *title
    \* **from** (*student* **natural join** *takes*) **join** *course* **using** (*course id*)

  - join on 은  조인 조건을 from 절에서 포함하는 방법을 제공하는 구문입니다.

    **select** *
     **from** *student* **join** *takes* **on** *student*.*ID* = *takes*.*ID*

  - outer join 은 조인 조건 자 (자연 조인, 조인 사용 또는 조인 온)로 인해 결과 관계의 어디에도 나타나지 않는 튜플을 유지하는 수단을 제공합니다.   
    유지 된 튜플은 결과 스키마를 따르기 위해 null 값으로 채워집니다.

- view relation 은 쿼리들의 결과를 포함하는 릴레이션으로 정의될 수 있습니다.  
  뷰들은 필요하지 않은 정보를 숨기는데 유용하게 사용됩니다.  그리고 하나 이상의 릴레이션으로 부터 정보를 단일 뷰로 모으는 데 유용하게 사용됩니다.  

- 트랜잭션(Transaction) 은 쿼리들의 시퀀스이고 하나의 테스크를 같이 수행하면서 업데이트 합니다.  
  트랜잭션은 commit 되거나 롤백 될 수 있습니다.   
  트랜잭션이 롤백 된 경우 트랜잭션에서 수행된 모든 업데이트들의 효과가 취소됩니다.

- Integrity constraint 은 인증된 사용자에 의해 만들어진 데이터베이스의 변화가 데이터의 일관성에서 손실이 되지 않도록 합니다.

- Referential-integrity 제약은 주어진 어트리뷰트의 집합에 대해,  
  한 릴레이션에 나타나는 값이, 다른 릴레이션의 특정 어트리뷰트 집합에 대해서도 나타나도록합니다.  

- Domain constraint 는 한 어트리뷰트와 관련될 수 있는 가능한 값들의 집합을 명시합니다.  
  이러한 제약들은 특정 어트리뷰트에 대해 null 값들의 사용을 금지할 수 있습니다.

- Assertion 는 항상 참이여야만 하는 state predicate(조건자) 를 나타내는 선언적 표현입니다. 

- SQL 의 DDM 은 built-in domain type 을 정의하는 것을 지원합니다. - date 나 time, 사용자 정의 타입 등 

- 쿼리들의 효율적인 처리를 위해 인덱스가 중요합니다. 또한 integrity constraint 을 효줄적으로 강제하기 위해서도 중요합니다.  
  SQL 표준의 파트는 아니지만, 대부분의 디비 시스템은 인덱스 생성을 위한  SQL 명령어를 제공합니다.

- SQL authorization mechanism 을 사용하면 데이터베이스의 다양한 데이터 값에 대해 허용되는 액세스 유형에 대해 데이터베이스 사용자를 구별 할 수 있습니다.

- 사용자가 조직에서 수행하는 다른 역할에 따라 사용자 권한 집합을 할당 할 수 있습니다.

## Chapter 5

- SQL 쿼리는 host 언어들로 부터 내장되고 동적인 SQL 을 통해 호출됩니다.  
  ODBC 와 JDBC 기준들은 어플리케이션 프로그램 인터페이스를 정의하여 SQL 데이터 베이스를 C와 Java 언어 프로그램으로 접근할 수 있도록 합니다. 
- 함수들과 절차들은 정의될 수 있습니다. SQL procedural extension 을 사용하여-  이것 반복문과 조건문을 허용합니다.  
- 트리거들 특정 이벤트가 일어나고 조건을 만족했을 때, 자동적으로 실행되는 액션들을 정의합니다. 
- 일부 쿼리들, transitive closure 같은 것들은 반복이나 재귀적 SQL 쿼리를 사용하여 표현될 수 있습니다.  
- 반복은 재귀적인 view 나 clause 정의를 가진 재귀를 사용하여 표현됩니다. 
- SQL 는 다양한 aggregation 기능을 제공합니다.  랭킹이나, 윈도우, 피봇, rollup, cube 연산등,  
  이것들은 일부 aggreate 한 표현을 단순화 하고, evaluation 을 더 효과적으로 만듭니다. 



## Chapter 6

- 데이터베이스 설계는 주로 데이터 베이스 스키마 설계를 포함합니다.  
  E-R 데이터 모델은 널리 사용되는 데이터 모델입니다.  이는 데이터, relationship, contraint 를 보기 위한 시각적 표현을 제공합니다. 
- E-R 모델은 디비 설계 과정을 위해 만들어 졌습니다.  
  이것은 하나의 통합 스키마의 명세를 허용하여 데이터 베이스 설계를 편하게 하기 위해 개발되었습니다.  
  이러한 스키마는 데이터베이스의 전반적인 논리 구조를 표현합니다.  
  이 전체 구조는  E-P 다이아그램으로 시각적으로 표현될 수 있습니다.
- 한 엔티티는  하나의 오브젝트입니다.- 이것은 실세계에서 존재하고 다른 오브젝트와 구분할 수 있습니다.  
  오브젝트를 표현하는 어트리뷰트의 한 집합을 연관지어 구분할 수 있습니다. 
- relationship 은 여러 엔티티 사이의 연관 입니다.  
  relationship set 은 같은 타입의 relationship의 모음이고,entity set은 같은 타입의 엔티티 의 모음입니다.
- superkey, candidate key, primary key 는 entity 와 relationship set 을 관계 스키마에서 하는 것 처럼 적용합니다.  
  @@







## Chapter 13

- 파일을 논리적으로 다스크 블록들에 매핑되는 레코드들의 시퀀스롤 구성할 수 있습니다.   
  데이터베이스를 파일로 매핑하기 위한 방식중 하나는, 여러 파일을 사용하고, 어떠한 주어지 파일에 하나의 고정된 길이의 레코드로 저장을 합니다.   
  다른 방법은 레코드를 위한 다양한 길이를 수용합니다. slotted-page 방식은 디스크 블록에서 가변 길이의 레코드를 다루기 위해 주로 사용되는 방식입니다.  
- 데이터가 디스키와 메모리 사이에서 하나의 블록 단위로 전송되기 때문에, 파일 레코드에서 단일 블록에 관련된 레코드들로 저장을하는 것이 효과적입니다.  
  만약 하나의 블록 접근을 가지고 여러 레코드에 접근할 수 있으면 디스크 엑세스를 많이 줄일 수 있습니다.  
  디스크 접근은 일반적으로 디비 시스템의 병목을 만들기 때문에, 블록에 레코드를 잘 할당하는 것은 성능에 많은 영향을 줍니다.
- data dictionary (system catalog)는 메타데이터의 트랙을 유지합니다. (데이터들에 관련된 정보)
- 디스크 접근의 수를 줄이는 방법은 가능한 많은 블록들을 메모리에 유지하는 것입니다.  
  모든 블록을 메모리에 유지할 수 없기 때문에, 블록 저장을 위한 메모리 공관 할당을 잘 관리해야 합니다.  
  buffer 는 디스크 불록의 복사본을 저장하는 메모리의 파트입니다.  
  버퍼 공간의 할당을 관리하는 subsystem 을 buffer manager 라고 합니다.
- Column 기반 저장 시스템은 데이터 warehousing application 에서 좋은 퍼포먼스를 보입니다.



## Chapter 14

- 대부분의 쿼리들은 파일의 레코드에서 작은 부분만 참조합니다.   
  이러한 레코드들을 찾는 오버헤드를 줄이기 위해서 디비를 저장하는 파일의 indices 생성합니다.
- 두가지 종류의 indice 를 사용할 수 있습니다.  - dense/sparse indices  
  Dense indices 는 모든 search-key value 에 대한 엔트리들을 포함합니다.  
  Sparse indices 는 일부의 search-key value 에 대한 엔트리들을 포함합니다.
- 서치 키의 정렬 순서가 릴레이션의 정렬 순서와 일치하면, 그 서치 키의 index 를 clustering index 라고 합니다.  
  그렇지 않은 indices 를 nonclustering 이나 나  secondary indices 라고 합니다.  
  Secondary indices 는 clustering index의 검색 키가 아닌 검색 키를 사용하는 쿼리의 성능을 향상시킵니다.  그러나 디비의 수정이 있을 때 오버헤드가 발생합니다.  
- index-sequential file 은 디비 시스템에서 사용되는 가장 오래된 index 스키마 중 하나입니다.  
  검색 키 순서로 레코드를 빠르게 검색 할 수 있도록 레코드가 순차적으로 저장되고 비 순차 레코드가 함께 연결됩니다.   
  빠른 랜덤 액세스를 허용하기 위해 인덱스 구조를 사용합니다.
- index-sequential file 의 주 단점은 파일이 커짐에 따라 성능이 저하된다는 것 입니다.  
  이를 극복하기 위해 B+ tree index 를 사용합니다.
- B+tree index 는 밸런스 트리의 형태를 취합니다. 이는 루트까지의 모든 경로가 동일한 길이릐 트리입니다.   
  B+tree 는 릴레이션에서 레코드의 수 N 을 밑으로 하는 로그 스케일에 비례합니다. - 각 nonleaf 노드는 N 개의 포인터를 저장합니다.  
  N 의 값은 주로 50에서 100정도 됩니다.  
  B+tree 는 balance 이진 트리 구조보다 더 짧습니다. - record 를 위치시키기 위한 디스크 접근이 더 적다.
- B+ 트리 조회는 간단하고 효율적입니다. 그러나 삽입과 삭제는 다소 복잡하지만 여전히 효율적입니다. B- 트리에서 조회, 삽입 및 삭제에 필요한 연산의 수는 각 비 리프 노드가 N 개의 포인터를 저장하는 관계에있는 레코드 수의 밑수 N에 대한 로그에 비례합니다.
- B+ 트리를 사용하여 레코드를 포함하는 파일을 색인화하고 레코드를 파일로 구성 할 수 있습니다.
- B- 트리 인덱스는 B+ 트리 인덱스와 유사합니다. B- 트리의 주요 이점은 B- 트리가 검색 키 값의 중복 저장을 제거한다는 것입니다. 주요 단점은 전체적인 복잡성과 주어진 노드 크기에 대한 팬 아웃 감소입니다. 시스템 설계자는 거의 보편적으로 실제로 B- 트리 인덱스보다 B- 트리 인덱스를 선호합니다. 
- 해싱은 메인메모리 뿐아니라 disk 기반 시스템에서 인덱스들을 생성하기 위해 사용되는 테크닉 입니다.
- B+와 같은 Ordered indices 들은 단일 속성들을 포함하는 동일 한 조건을 기반으로 selection 에 대해 사용될 수 있습니다.  
- selection 조건에서 포함되는 여러 attribute 들이 있을 때, 여러 인덱스에서 검색된 레코드 식별자를 교차 할 수 있습니다.
- 기본 B- 트리 구조는 초당 매우 많은 수의 임의 쓰기 / 삽입을 지원해야하는 애플리케이션에 적합하지 않습니다. 로그 구조 병합 트리 및 버퍼 트리를 포함하여 쓰기 / 삽입 비율이 높은 워크로드를 처리하기 위해 여러 가지 대체 인덱스 구조가 제안되었습니다.
- 비트 맵 인덱스는 고유 한 값이 거의없는 속성을 인덱싱하기위한 평균 압축 표현을 제공합니다. 교차 작업은 비트 맵에서 매우 빠르므로 여러 속성에 대한 쿼리를 지원하는 데 이상적입니다.
- R- 트리는 B- 트리의 다차원 확장; R- 트리 및 R *-트리와 같은 변형으로 공간 데이터베이스에서 인기가 있음이 입증되었습니다. 쿼드 트리와 같이 정기적으로 공간을 분할하는 인덱스 구조는 공간 조인 쿼리를 처리하는 데 도움이됩니다.
- 공간 인덱스 및 간격 B- 트리 특수 인덱스의 사용을 포함하여 시간 데이터를 인덱싱하기위한 많은 기술이 있습니다.

