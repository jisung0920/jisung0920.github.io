# Frequent Itemsets

데이터를 특징짓기위한 기술의 주요 종류 중 하나를 다룹니다. : the discovery of Frequent Itemsets.

이 문제는 종종 'association rule' 찾기로 보여집니다. 비록 나중에는 데이터의 더 복잡합 특징을 다루지만, 이 찾기는 기본적으로 Frequent Itemsets 찾기에 기반한 찾기 입니다.

우리는 데이터의 '마켓-바스킷' 모델 을 소개합니다. 이것은 본질적으로 다대다 관계입니다. 두가지 종류의 엘리먼트 사이의, item 과 baskets 이라고 불리는, 그러나 데이터의 쉐이프에 대한 어떤 가정을 가집니다. 이 빈도 아이템셋 문제는 같은 바구니에 많이 보이는 아이템의 집합을 찾는 문제입니다. 

이 문제는 3단원의 유사도를 찾는 것과는 다른 문제입니다.
여기서 우리는 특정 아이템들의 집합을 포함한 바구니들의 절대 값에 관심이 있습니다. 
3단원에서는 일반적으로 바구니에서 큰 비율 갖는 아이템을 찾았습니다.

이 차이는 이끕니다. 새로운 종류의 알고리즘을, 빈도아이템셋 찾기를 수행하기 위한.
우리는 A-Priori 알고리즘부터 시작합니다. 이는 후보로서 가장 큰 집합을 제거하면서 작동합니다. 더 작은 집합들을 먼저보고, 큰 집합이 그것의 부분집합과 상관없이 빈도가 높을 수 없는 것을 인식합니다.
우리는 A-Priori Algorithm으로 시작합니다. A-Priori Algorithm은 작은 세트를 먼저보고 큰 세트를 후보로 삼아 모든 하위 세트가 아니라면 큰 세트를 자주 사용할 수 없음을 인식하여 작동합니다.
그리고 기본 아이디어에 대한 다양한 개선안들을 고려하고 메인메모리에서 사용 가능한 대규모 데이터셋에 집줍합니다.

그다음, 우리는 추정 알고리즘을 다룹니다. 모든 빈도 아이템셋을 찾는 것은 보장 못하지만 더 빠르게 할 수 있는,
또한 이러한 종류의 알고리즘은, 병렬적으로 할 수 있고, 맵리듀스 공식을 사용할 수 있습니다. 
마지막으로는 어떻게 스트림 데이터에서 찾는지에 대해 간단하게 다룹니다.



## 6.1 The Market-Basket Model

마켓 가방 모델은 물체들의 두 종류들 사이의 다대다 관계의 일반적인 형태를 표현하기 위해 사용됩니다. 
우리는 아이템들을 갖고 있고, 바구니를 갖고 있습니다. 이는 transaction이라고도 불립니다.
각 바구니는 아이템셋으로 구성되어 있습니다. 그리고 일반적으로 우리는 바구니 안의 아이템의 수는 적다고 가정합니다. 전체 아이템의 수에 비해
바구니의 숫자는 일반적으로 매우 크다고 가정합니다. - 메모리에 넣을 수 없을 정도로
데이터는 바구니의 시퀀스로 구성된 파일로 표현됩니다. 
DFS에 따라, 바구니는 파일의 object 이고 각 바구니는 set of items 의 종류입니다.



### 6.1.1 Definition of Frequent Itemsets

직관적으로, 아이템의 집합, 많은 바구니에서, 이를 빈번하다고 합니다.  
포멀하게 만들어봅시다. 우리는 숫자 s 를 가정하고 이는 support threshold 라고 합시다.  
만약 I 가 아이템의 집합이면, I 에 대한 support 를 I 가 부분 집합인 바구니의 수 입니다.  
우리는 I 의 support 가 s 를 넘는다면 이를 *빈번하다* 라고 할 수 있습니다.

example 6.1

<img src="06.Frequent Itemsets.assets/image-20200707111932107.png" alt="image-20200707111932107" style="zoom:50%;" />

그림은 단어들의 집합입니다. 각 집합은 하나의 바구니이고 단어는 아이템 입니다.  
공집합에 대한 서포트는 9입니다. 그러나 일반적으로 공집합은 고려하지 않습니다. 아무런 의미가 없기 때문입니다.  
단일 집합(singleton sets) 중에 {cat},{dog} 은 확실히 빈번합니다. 'Dog'은 5번째 빼고 다 나왔습니다.(support = 7), 'Cat' 은 4,8 번 빼고 나왔습니다.(support = 6)  
'and' 도 많이 나왔습니다.

s=3 으로 두면, 5개의 frequent singleton 아이템셋이 나옵니다. {dot}{cat}{and}{a}{training}

이제 doubleton을 봅시다. doubleton은 그 안에 있는 아이템이 같이 빈번하지 않으면 빈번할 수 없습니다.   
그래서 10개의 가능한 더블톤밖에 없습니다. 

<img src="06.Frequent Itemsets.assets/image-20200707113700929.png" alt="image-20200707113700929" style="zoom:50%;" />

{dog, training} 은 4와 6에서 만 나옵니다. support 는 2 이고 그래서 빈번하지 않습니다.

s=3 인경우 <img src="06.Frequent Itemsets.assets/image-20200707113807297.png" alt="image-20200707113807297" style="zoom:50%;" />

이 쌍들이 빈번합니다.

triples을 봅시다. {dog,cat,a} , {dog,a,and} 등이 있습니다.

이것이 빈번 하려면 그 부분집합이(더블톤) 빈번해야합니다.



#### On-Line vs Brick-and-Mortar Retailing

3.1.3에서 온라인 리테일러는 아이템에 대한 유사도 측정을 사용한다고 제시했습니다. 아이템 쌍을 찾기위해 공통적으로 그 고객들의 중요한 부분을 갖고 있는,  그것들이 많이 팔리지 않을 수도 있지만   
온라인 판매는 그러면, 광고를 할 수 있습니다. 한 아이템 쌍을 일부 고객들에게, 그 쌍의 다른 아이템을 샀었던.  
이러한 방법ㅂ론은 brcks-and-mortar 판매에는 적합하지 않습니다.  
왜냐하면, 아이템을 사는 사람의 수와는 상관없이, 이것은 그 아이탬을 판매하는데 효율적으로 광고를 할 수 없습니다.  
그래서 3단원의 기술은 brcks-and-mortar 상황에 대해 잘 유용하지 않습니다.

반대로, 온라인 소매상은 이 단원에서 이야기할 분석을 필요로합니다.  
왜냐면 이것은 빈번하게 나타나는 아이템셋에 대한 탐색하는 것을 설계하기 때문입니다.   
만약 온라인 판매자가 빈번한 아이템셋으로 제한한다면, 그들은 모든 기회를 놓칠 것 입니다ㅏ. Long tail 에서 제시될 수 있는 고객 개개인에 대한 광고를 선택할 수 있는



### 6.1.2 Applications of Frequent Itemsets

market-basket 모델의 처음 적용사례는 실제 장바구니의 분석하는데 있었습니다.  
슈퍼마켓들이 실제 장바구니의 모든 물품을 기록합니다. 여기서 items 들은 마트에서 파는 여러 물건들이고 basket 은 단일 장바구니의 아이템들의 집합입니다.  
유명체인점에서는 거의 100,000 개의 종류의 아이템들을 팔고, 백만개의 장바구니 데이터가 있습니다.   

빈도 아이템셋을 찾음으로써, 판매자들은 어떤게 주로 같이 팔리는지 알 수 있습니다.   
특히 중요한 것은 쌍들이나 더 큰 아이템 셋들이 있다는 것입니다. 그것은 단일로 사는 것이 기대되는 것보다 더 많이 빈번하게 발생합니다.  
우리는 6.1.3 단원에서 이 문제의 양상에 대해 논합니다. 그러나 그전에 빈도 아이템셋을 찾는 작업을 단순하게 생각해봅시다.   
판매를 할때 핫도그와 머스타드가 같이 잘팔립니다. 핫도그 가격을 낮추고 머스타드 가격을 높이는 방식으로 이득을 얻을 수 있습니다.

이러한 종류의 유명한 예시는 '기저귀와 맥주' 입니다. 두개의 연관성을 기대하기는 어렵지만, 데이터 분석을 통해 한 체인점은 발견했었다. 기지귀를 사는 사람이 일반적으로 맥주를 살 확률이 높다고.  
이 이론은 다음과 같습니다. 만약 기저귀를 산다면, 집에 애기가 있을 것이고, 애기가 있다면, 아마 밖에서 술을 마시기 어려울 것입니다. 그래서 맥주를 집에서 마시는 것입니다.  
우리가 핫도그와 겨자를 위해 제안한 것과 같은 종류의 마케팅 방법은 기저귀와 맥주에 사용될 수 있습니다.  

그러나 빈도 아이템 북성의 적용은 시장에만 제한되지 않습니다.  
다음과 같은 상황에도 사용할 수 있습니다.

1. Related concepts : 아이템이 단어고, 바스켓이 문서가 됩니다.  
   문서는 단어를 포함합니다.  
   만약 우리가 많은 문서에서 나오는 단어의 집합을 찾는다면, 그 집합은 대부분 불용어가 될 것입니다. 이것은 6.1 의 예시에서 볼 수 있습니다.  
   고양이와 개에 대해 이야기하는 발췌문을 찾으려는 의도가 있었음에도 불구하고 자주 사용되는 항목 세트에서 중지 단어 "and"와 "a"가 두드러졌습니다.  
   그러나 만약 모든 불룡어를 무시한다면, 공동적으로 표현하는 단어의 쌍 중 빈도 쌍을 찾을 수 있을 것입니다.  
   예를들면, brad Angelina 와 같이 빈도 쌍이 보여질 것입니다. 
2. Plagiarism : 아이템이 문서들이 되고, 바스켓이 문장들 입니다. 문서는 그 문서 안에 문장이 있다면, 문장 '안' 에 문서가 있습니다.  
   이 배열은 거꾸로 나타나지만 정확히 필요한 것이므로 항목과 바구니 사이의 관계는 임의의 많은 관계라는 것을 기억해야합니다. 즉, "in"은 "part of"라는 일반적인 의미를 가질 필요가 없습니다. 이 응용 프로그램에서는 여러 바구니에 함께 나타나는 항목 쌍을 찾습니다. 그러한 쌍을 찾으면 여러 문장을 공통으로 공유하는 두 개의 문서가 있습니다. 실제로, 하나 또는 두 개의 공통 문장조차 표절의 좋은 지표입니다.
3. Biomarkers :유전자 또는 혈액 단백질과 같은 바이오 마커와 질병이라는 두 가지 유형의 품목을 두십시오. 각 바구니는 환자에 대한 데이터 세트입니다 : 그들의 게놈 및 혈액 화학 분석 및 질병의 병력. 하나의 질병과 하나 이상의 바이오 마커로 구성된 빈번한 항목 집합은 질병에 대한 검사를 제안합니다.



### 6.1.3 Association Rules

1. 이 단원의 주제는 데이터로 부터 빈도 아이템셋을 추출하는 것이지만, 이 정보는 종종 제시됩니다. 'association rule' 이라 불리는 if-then 규칙의 모음으로,  
   이 규칙의 형태는 $I \rightarrow j$ 입니다. I 는 아이템들의 집합이고, j 는 아이템입니다.   
   연관규칙의 의미는 한 바스켓에서 I 안의 모든 아이템들이 나타난다면, j 가 나타날 확률이 높다(likely)는 것입니다.  

2. 우리는 이 'likely' 의 개념을 신뢰도(confidence)를  정의 함으로서 공식화합니다. 신뢰도는  $I \rightarrow j$  는  $I\cup {j}$ 에 대한 서포트와 I 에 대한 서포트의 비율로 정의됩니다.  
   이는 규칙의 신뢰도는 J 또한 포함 하는 I의 모두를 가진 바스켓의 부분이 됩니다.    
   **Example 6.2**   
   규칙 $\{cat,dog\} \rightarrow and$  의 신뢰도는 3/5 입니다. cat, dog 은 5개에서 나왔고 and 는 그중 3개에서 나왔습니다.  
   $\{cat\} \rightarrow kitten$ 는 1/6 입니다. cat 은 6번 나왔고 그 중 kitten 은 (5) 에서만 나왔습니다.

   

3. 규칙의 왼쪽 부분의 서포트가 큰 경우에는, 신뢰도 하나만으로도 유용할 수 있습니다.  
   예를들어 우리는 사람들이 머스타드를 살 때 핫도그를 살 가능이 높다는 것을 알 필요가 없습니다. 이것은 6.1.2 에서 더 이야기합니다.  
   그러나 종종 더 많은 가치가 있습니다. 연관규칙이 실제 관계를 잘 반영한다면, 왼쪽에 있는 아이템들이 오른쪽 아이템에 어느정도의 영향을끼치는지.   

4. 그래서 interest 를 정의 하였습니다.  신뢰도와 j를 포함하는 바스킷의 부분의 차이 입니다. 만약 I 가 j 아무런 영향이 없다면, 우리는 J 가 포함된 I를 포함하는 바스킷의 부분이 j 를 포함한 바스킷의 모든 부분과 동일하다고 예상됩니다.  
   이와 같은 규칙의 interest 는 0 입니다.  
   그러나 다음 상황은 정보적으로나 기술적으로 흥미롭습니다.  
   만약 규칙이 높은 interest 를 갖거나 ( I 가 있는 바스킷에서 어느정도 J 가 발생되는) 높은 음수의 interest 인 경우 (I가 j 를 discourage 하는 것).  
   신뢰도 - 전체중 j 비율.   
   Example 6.3.  
   맥주와 기저귀 예시에서 실제 주장연관 규칙 $\{ diapers\} \rightarrow beer$  는 높은 interest 를 갖습니다.  
   이는 맥주를 산 기저귀 구매자의 부분 전체 맥주를 산사람 중에서의 비율보다 높습니다.

5. ex6.3 설명

### 6.1.4 Finding Association Rules with High Confidence

1. support 임계값 s 이상인 빈도 아이템 셋을 찾는 것이 가능합니다.
2. $I\rightarrow j$ 규칙을 찾으려면, I의 support 가 높아야 합니다. 
3. J가 n개의 빈도 아이템셋의 집합이라면, 연관규칙이 생길 가능성은 n 개 입니다.  다시말해 $J -\{j\} \rightarrow j$ 의 연관규칙만 가능성이 있습니다.  
   J 가 빈번하면,   $J -\{j\}$ 반드시 빈번합니다.
4. 빈번 아이템 셋이 많지 않으면, 연관규칙 후보가 많지 않다.



## 6.2 Market Baskets and the A-Priori Algorithm

### 6.2.1 Representation of Market-Basket Data

1. 마켓-바스켓 데이터를 베스킷 별로 저장할 수 있고, 그 데이터는 dfs에나 기본 파일로 저장할 수 있다.
2. example6.4  
   {23,455,2003} {3,543,234,65} 와 같이 {}는 바스킷, 정수는 아이템으로 표현 할 수 있다.
3. 병렬처리에 대해서는 6.4.4 단원에서 다룬다.
4. 바스킷 파일이 너무 커 메모리에는 못올리고 디스크에서 읽어오면서 사용할 수 있다.  
   바스킷 사이즈가 작은 경우 메모리에서 모든 쌍을 생성할 수 있다.   
   디스크에서 읽어오는 것보다, 쌍을 생성하는 시간이 짧다.
5. 부분집합의 크기가 커지면 (아이템이 많아지면) 시간이 더 크게 소요된다.  
   n개의 아이템에 k 크기의 부분집합을 만드는데 약 $n^k / k!$ 이 소요된다.   
   큰 경우 디스크에서 읽어오는 시간보다 더 오래 걸릴 수 있다.   
   그러나 
   1. 대부분 k=2,3 정도의 빈도 아이템 셋을 요구한다.
   2. 큰 k 를 필요로하는 경우, 빈도 아이템을 찾는 것에 필요없는 많은 아이템 셋을 제거할 수 있다.
6.  검사하는 작업은 파일의 크기에 비례한다고 가정할 수 있다.(k보다는) - 그래서 실행시간을 파일의 디스크 블록을 읽는 횟수에 따라 측정할 수 있다. 
7.  따라서 알고리즘은 바스켓 파일을 통과하는 패스 수를 특징으로 할 수 있으며 실행 시간은 바스켓 파일을 통과하는 패스 수에 해당 파일 크기를 곱한 값에 비례합니다.  
   데이터 크기는 상황마다 다르기 때문에, 알고리즘은 패스의 수를 줄이는 것에 집중합니다.

### 6.2.2 Use of Main Memory for Itemset Counting

1. 
2.  
3.  



