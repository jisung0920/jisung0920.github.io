스트림을 요약하는 방식,  

어떻게 스트림의 샘플을 잘 만드는지

그리고 불필요한 요소들을 어떻게 걸르는지 가 토픽



1.스트림을 특정 방식으로 요약하는 방식,  

어떻게 스트림의 샘플을 잘 만드는지

그리고 불필요한 요소들을 어떻게 걸르는지 가 토픽



2.스트림을 고정된 길이의 윈도우로 보는 것 



### 4.3.2 The Bloom Filter

불룸 필터는 다음으로 구성됩니다.

1. 모두 0 으로 초기화된 n개의 bit 의 배열
2. 해시 함수의 모음 $h_1,h_2,\dots, h_k$   
   각 해시 함수는 'key' 값을 n 개의 버킷으로 맵을 합니다. (bit-array 의 n개의 비트에 따라)
3. 키 값들 m 의 집합 S

블룸필터의 목적은 S 안의 키들을이 있는 모든 스트림 요소들이 통과하도록 허용하는 것 입니다.   
S 안에 키가 아닌 것들의 스트림 요소들은 대부분 차단됩니다.

bit 배열을 초기화 하기 위해 모든 비트를 0으로 둡니다.   
S 안의 키 값을 인자로 받아 k 개의 해시 함수를 각각 사용합니다.  
S 안의  키 값 K와 특정 해시 함수 $h_i$ 에 대한, $h_i(K)$ 인 각 비트들을 1로 둡니다.

키 K 를 테스트하기 위해서,  
$h_1(K),h_2(K),\dots, h_k(K)$  
이것들이 bit-array 에서 모두 1인지를 체크합니다.   
만약 모두 1 이라면, 그 스트림 요소는 통과하게 두고   
하나 이상의 0 이 나온다면 K 가 S 가 아닐 수 있어서, 차단합니다.



### 4.3.3 Analysis of Bloom Filtering

S 에 키 값이 있으면, 그 요소는 확실이 블룸 필터를 거칠 것입니다.  
그러나 만약 키가 S 에 있지 않더라도, 패스될 수 있습니다.  
우리는 이 false positive 의 확률을 어떻게 계산하는지 이해해야합니다.  
n개의 bit-array 길이, S 안의 m 개의 맴버, k개의 해시 함수 를 가지고 알아봅시다.  

이 모델은 타겟에 다트 던지기 모델입니다.   
우리가 x개의 타겟과 y개의 다트를 갖고 있다고 생각해 봅시다.  
모든 다트는 타켓에 맞추는 확률이 동일합니다.   
다트들을 던지고나서,  우리가 적어도 한번 맞췄을 것이라고 기대하는 타겟이 몇개나 될까요?  
이 분석은 3.4.2와 유사합니다.

- 다트가 주어졌을 때, 주어진 타겟을 못맞출 확률은 $1- \frac{1}{x} = \frac{(x-1)}{x}$ 입니다.
- y개의 다트 중 아무것도 히트가 없을 확률은 $(\frac{x-1}{x})^y = (1-\frac{1}{x})^{x(\frac{y}{x})} $ 입니다.
- 작은 $\epsilon$ 에 대해  $(1-\epsilon)^{\frac{1}{\epsilon}} = \frac{1}{e}$ 추정을 사용해서 위의 확률은 $e^{-\frac{y}{x}}$ 로 표현할 수 있습니다.

#### example 4.3

우리는 위의 계산을 사용할 수 있습니다. 비트배열에서 실제 1이 기대되는 숫자를 얻가 위해.  
각 비트를 하나 하나의 타겟으로 볼 수 있고, S의 각 맴버를 하나의 다트로 생각할 수 있습니다.  
그러면 주어진 비트가 1이 될 확률은 하나 이상의 다트가 그 비트에 해당하는 타겟을 맞출 확률입니다.   
십억개의 S 가 있기 때문에, 우리는 y = 10^9 개의 다트를 갖고있습니다.    
팔십억개의 비트가 있기 때문에, x=8*10^9 의 타겟이 있습니다.  
그래서 주어진 타겟이 히트가 되지 않을 확률은 $e^{-y/x} = e^{-1/8}$ 이고  
hit 가 있을 확률은 $1-e^{-1/8}$ 이고 그 값은 약 0.1175 입니다.   



우리는 이 모델을 일반적 상황에 적용할 수 있습니다.  
n개의 bit-array 길이, S 안의 m 개의 맴버, k개의 해시 함수 를 갖는다고 봅시다.  
타겟의 수는 x=n 이고, 다트의 수는 y=km 입니다.  
그래서 비트가 0으로 남을 확률은 $e^{-km/n}$ 입니다.  
우리는 0비트의 부분이 꽤 크거나 S의 맴버가 아닌것이 적어도 한번 0으로 되는 확률 작아지기를 원합니다.  
예를들어, 우리가 k를 선택한다면, 해시함수의 수를 n/m 이나 더 적게 선택한다면,  
0의 확률이 적어도 $e^{-1}$ , 37% 가 됩니다.   
일반적으로 false positive 의 확률은 하나의 1비트의 확률입니다. - 그것은 $1-e^{-km/n}$ 이고 k번 반복하여($(1-e^{-km/n})^k$) 입니다.





## 4.4 Counting Distinct Elements in a Stream

이 섹션에서는 스트림에서 수행 할 수있는 간단한 세 번째 처리 유형을 살펴 봅니다.  
이전 예제 (샘플링 및 필터링)와 마찬가지로 합리적인 양의 주 메모리에서 원하는 작업을 수행하는 것은 다소 까다로워서 다양한 해싱과 무작위 알고리즘을 사용하여 스트림 당 필요한 공간을 거의 차지하지 않고 원하는 것을 얻습니다. .

4.4.1 The Count-Distinct Problem

스트림 엘리먼트들이 전체 집합의 일부에서 선택되었다고 가정해봅시다. 우리는 얼마나 많은 엘리먼트들이 스트림에서 나타나는지 알고 싶습니다, 시작스트림부터나 특정 시간부터 세면서

example 4.5



## 4.6 Couting Ones in A Window

우리는 이제 스트림에서 카운팅하는 문제를 봅니다.  
우리가 바이너링 스트림에서의 N 길이의 윈도우를 갖는다고 생각해봅시다.   
우리는 모든 시간에 쿼리에 대답할 수 있기를 원합니다. '최근 k 비트 중 몇개의 1 이 있었는지' (k<N)  
이전 세션에서는, 우리가 전체 윈도우를 저장하지 못하는 상황을 다뤘습니다.  
바이너리 상황에 대한 추정 알고리즘을 보여준 후,  
우리는 어떻게 이 아이디어를 숫자를 더하는 것으로 확장하는지에 대해 이야기합니다. 

### 4.6.1 The Cost of Exact Counts

최근 k bit 안에서 1의 숫자를 정확하게 샐 수 있기를 원한다고 생각해봅시다.  
그러면 우리는 윈도우의 모든 N 개의 비트를 저장하는 것이 필요하다고 주장할 것입니다. 어더한 representation 으로서, 이는 N보다 더작은 것은 동작하지 못한다고   
증명하자면, 우리가 N 보다 작은 표상이 있다고 생각해봅시다.  
2^N 표현보다 더 작지만  N 비트의 2^N 시퀀스가 있기 때문에, 표상이 같지만 다른 비트열 w, x 가 반드시 있습니다.  w가 x 는 아니기 때문에, 그것들은 적어도 하나의 비트는 다를 것 입니다.  
w 와 x 의 최근 k-1 가 동일하다고 두었다면, 그것들의 k번째 비트는 다르게 두어야 합니다.(오른쪽 끝에서 부터)

#### example 4.10

w = 0101 , x = 1010  이면 k=1 이다. 오른쪽에서부터 보면 1번 위치에서 다르다.  
w = 1001 , x = 0101 이면, k=3 이다. 오른쪽부터 3번째 위치에서 다르다. 

윈도우의 내용을 표현하는 데이터는 비트 시퀀스가 w와 x를 모두 나타낸다고 가정해봅시다.  
쿼리 '최근 k 비트에서 1이 몇개가 나왔는지' 를 수행해봅시다.  
Query-answering 알고리즘은 동일한 답을 제공할 것입니다, 그 윈도우가 w나 x를 포함하든지 간에,  
왜냐하면, 그 알고리즘은 오직 그것들의 표상만 볼 수 있기 때문입니다.  
그러나 정확한 답은 확실히 다릅니다. 이 두개의 비트열과는  
그래서 우리는 증명합니다. 우리가 적어도 N개의 비트를 사용해야한다고(최근 k에 대한 쿼리를 하기 위해서는)

결국, 우리는 N 비트가 필요합니다. 우리가 물을 수 있는 쿼리가 N길이의 전체 원도우에서 1이 몇개 있는지에 대해 질문을 할지라도  
이 논리도 위의것과 유사합니다.  
우리가 N보다 적은 비트를 윈도우를 표현하기 위해 사용한다고 생각해봅시다. 그래서 우리는 w와 x 그리고 k 를 위와같이 찾을 수 있습니다.  
w와 x 가 1의 같은 숫자를 갖는다면, 4.10 과 같은.  
그러나 만약 현재 윈도우를 N-k비트 까지 있었고, 우리가  

### 4.6.2 DGIM 알고리즘

이 알고리즘은 N 비트의 윈도우를 표현하는 O(log^2N) 비트 를 사용하는 알고리즘입니다.  
이것은 윈도우에서 1의 숫자를 추정하고 에러는 50%를 넘지 않습니다.  
나중에 향상된 버전에서 동일한 비트를 사용해서 에러를 상수비율로 줄일 수 있습니다.  

스트림의 각 비트들은 타임스템프를 갖습니다. 이것은 그것이 도착한 시간입니다.  
첫번째는 1 두번째는 2 와 같은 식으로 수행합니다.  
우리는 오직 N길이의 윈도우 안에서 위치를 구분해는 것만 필요하기 때문에 우리는 mod N 의 타임스템프를 표현합니다 그래서 그것들은 $log_2N$ 비트로 표현될 수 있습니다.  
만약 우리가 스트림에서 봤던 비트의 전체 수 mod N 을 저장한다면, 현재 창에서 해당 타임 스탬프가있는 비트가있는 타임 스탬프 모듈로 N을 결정할 수 있습니다.  

윈도우를 버킷들로 나눌 수 있습니다.  

1. 오른쪽 끝(최근) 의 타임스템프
2. 버킷의 1의 수,  
   이 숫자는 2의 power 가 되어야 합니다.  
   그리고 우리는 1의 수를 버킷의 **사이즈** 라고 합니다.

버킷을 표현하기 위해, 우리는 log_2N 비트가 필요합니다. 

@@

- 오른쪽 끝의 버킷은 항상 1을 가진 위치이다.
- 모든 1을 가진 위치는 특정 버킷에 있다.
- 한 위치에서 2개 이상 버킷을 갖을 수 없다.
- 어떤 주어진 사이즈에서 특정 최대 사이즈까지의 버켓은 하나 혹은 두개가 있다.
- 모든 사이즈는 파워 2 이다.
- 버킷은 사이즈가 줄어들지 안흔다. 우리가 왼쪽으로 이동하더라도





---

## 4.2 Sampling Data in a Stream

스트림으로 부터 믿을만한 샘플들을 추출하는 것을 봅니다.  다소 특이한 방식으로 해싱을 사용하는 트릭이 있습니다.

### 4.2.1 A Motivating Example

일반적인 문제는 스트림의 부분집합을 선택하는 것입니다.  
그래서 우리는 쿼리를 요청할 수 있습니다. 선택된 부분집합에 대해,  
그리고 전체로서 스트림을 통계적으로 대표하는 답을 할 수 있습니다.  
만약 우리가 요청된 쿼리가 무엇인지 알고 있다면, 수행할 수 있는 많은 방법들이 있습니다.  
그러나 우리는 샘플에서 ad-hoc 쿼리를 할 수 있는 작업을 허용할 수 기술에 대해 살펴볼 것입니다.  
우리는 특정 문제에 대해 살피고 이로부터 일반적인 아이디어를 도출해 냅니다.

예시 : 한 검색 엔진이 쿼리의 스트림을 받습니다. 그리고 그것은 사용자의 일반적인 움직임을 학습하기 원합니다.  
우리는 튜플이 (사용자, 쿼리, 시간) 으로 구성된 스트림이라고 가정합니다.  
우리는 '일반적인 사용자의 쿼리들의 어떤 부분이 지난달에 반복되었나' 에 대한 답을 하길 원합니다.   
우리가 오직 스트림의 1/10 만 저장할 수 있다고 가정해봅시다.  

명확한 접근은 0부터 8까지의 무작위 수들을 발생시켜서 각 쿼리에 대해 받으면 됩니다.  그래서 무작위 수가 0 인 튜플만 저장하면 됩니다.  
우리가 그렇게 하면 평균적으로 1/10 개의 쿼리만 저장됩니다.  
통계적 변동은 데이터안의 노이즈로 될 것이지만, 만약 사용자가 많은 쿼리를 발생시킨다면, 큰수의 법칙이 많은 사용자들이 1/10 의 저장된 쿼리와 많이 가까워진다는 것을 확신할 수 있습니다.

그러나 이런 방식은 우리에게 잘못된 답을 줍니다. 사용자에 대해 중복된 쿼리의 평균 숫자를 묻는 쿼리에게 대해서  
사용자가 s 검색 쿼리를 지난 한달동안 한번 수행하고, d 검색 쿼리를 2번, 3번 이상의 쿼리는 없었다고 가정해 봅시다.   
1/10 번째 샘플 쿼리가있는 경우 해당 사용자의 샘플에서 한 번만 실행 된 검색 쿼리의 s / 10을 볼 수 있습니다.  
두 번 발행 된 d 검색 쿼리 중에서 샘플에는 d / 100 만 두 번 나타납니다.  
이 분수는 쿼리의 두 발생이 모두 1/10 샘플에있을 확률의 d 배입니다.  
 전체 스트림에서 두 번 나타나는 쿼리 중 18d / 100이 정확히 한 번 나타납니다.  
이유를 확인하려면 18/100은 두 발생 중 하나가 선택한 스트림의 1/10에있을 가능성이고 다른 하나는 선택되지 않은 9/10에있을 확률입니다.

s가 샘플에 있을 확률은 1/10 이고

d 가 샘플에 있을 확률은 

전체 스트림의 1/10 만 샘플링 할 수 있는 경우, 샘플링을   
1/10 의 스트림 안에 두번 나타난 쿼리 중 정확히 18d/100 이 한번 나타납니다.@@