스트림을 요약하는 방식,  

어떻게 스트림의 샘플을 잘 만드는지

그리고 불필요한 요소들을 어떻게 걸르는지 가 토픽



1.스트림을 특정 방식으로 요약하는 방식,  

어떻게 스트림의 샘플을 잘 만드는지

그리고 불필요한 요소들을 어떻게 걸르는지 가 토픽



2.스트림을 고정된 길이의 윈도우로 보는 것 



### 4.3.2 The Bloom Filter

불룸 필터는 다음으로 구성됩니다.

1. 모두 0 으로 초기화된 n개의 bit 의 배열
2. 해시 함수의 모음 $h_1,h_2,\dots, h_k$   
   각 해시 함수는 'key' 값을 n 개의 버킷으로 맵을 합니다. (bit-array 의 n개의 비트에 따라)
3. 키 값들 m 의 집합 S

블룸필터의 목적은 S 안의 키들을이 있는 모든 스트림 요소들이 통과하도록 허용하는 것 입니다.   
S 안에 키가 아닌 것들의 스트림 요소들은 대부분 차단됩니다.

bit 배열을 초기화 하기 위해 모든 비트를 0으로 둡니다.   
S 안의 키 값을 인자로 받아 k 개의 해시 함수를 각각 사용합니다.  
S 안의  키 값 K와 특정 해시 함수 $h_i$ 에 대한, $h_i(K)$ 인 각 비트들을 1로 둡니다.

키 K 를 테스트하기 위해서,  
$h_1(K),h_2(K),\dots, h_k(K)$  
이것들이 bit-array 에서 모두 1인지를 체크합니다.   
만약 모두 1 이라면, 그 스트림 요소는 통과하게 두고   
하나 이상의 0 이 나온다면 K 가 S 가 아닐 수 있어서, 차단합니다.



### 4.3.3 Analysis of Bloom Filtering

S 에 키 값이 있으면, 그 요소는 확실이 블룸 필터를 거칠 것입니다.  
그러나 만약 키가 S 에 있지 않더라도, 패스될 수 있습니다.  
우리는 이 false positive 의 확률을 어떻게 계산하는지 이해해야합니다.  
n개의 bit-array 길이, S 안의 m 개의 맴버, k개의 해시 함수 를 가지고 알아봅시다.  

이 모델은 타겟에 다트 던지기 모델입니다.   
우리가 x개의 타겟과 y개의 다트를 갖고 있다고 생각해 봅시다.  
모든 다트는 타켓에 맞추는 확률이 동일합니다.   
다트들을 던지고나서,  우리가 적어도 한번 맞췄을 것이라고 기대하는 타겟이 몇개나 될까요?  
이 분석은 3.4.2와 유사합니다.

- 다트가 주어졌을 때, 주어진 타겟을 못맞출 확률은 $1- \frac{1}{x} = \frac{(x-1)}{x}$ 입니다.
- y개의 다트 중 아무것도 히트가 없을 확률은 $(\frac{x-1}{x})^y = (1-\frac{1}{x})^{x(\frac{y}{x})} $ 입니다.
- 작은 $\epsilon$ 에 대해  $(1-\epsilon)^{\frac{1}{\epsilon}} = \frac{1}{e}$ 추정을 사용해서 위의 확률은 $e^{-\frac{y}{x}}$ 로 표현할 수 있습니다.

#### example 4.3

우리는 위의 계산을 사용할 수 있습니다. 비트배열에서 실제 1이 기대되는 숫자를 얻가 위해.  
각 비트를 하나 하나의 타겟으로 볼 수 있고, S의 각 맴버를 하나의 다트로 생각할 수 있습니다.  
그러면 주어진 비트가 1이 될 확률은 하나 이상의 다트가 그 비트에 해당하는 타겟을 맞출 확률입니다.   
십억개의 S 가 있기 때문에, 우리는 y = 10^9 개의 다트를 갖고있습니다.    
팔십억개의 비트가 있기 때문에, x=8*10^9 의 타겟이 있습니다.  
그래서 주어진 타겟이 히트가 되지 않을 확률은 $e^{-y/x} = e^{-1/8}$ 이고  
hit 가 있을 확률은 $1-e^{-1/8}$ 이고 그 값은 약 0.1175 입니다.   



우리는 이 모델을 일반적 상황에 적용할 수 있습니다.  
n개의 bit-array 길이, S 안의 m 개의 맴버, k개의 해시 함수 를 갖는다고 봅시다.  
타겟의 수는 x=n 이고, 다트의 수는 y=km 입니다.  
그래서 비트가 0으로 남을 확률은 $e^{-km/n}$ 입니다.  
우리는 0비트의 부분이 꽤 크거나 S의 맴버가 아닌것이 적어도 한번 0으로 되는 확률 작아지기를 원합니다.  
예를들어, 우리가 k를 선택한다면, 해시함수의 수를 n/m 이나 더 적게 선택한다면,  
0의 확률이 적어도 $e^{-1}$ , 37% 가 됩니다.   
일반적으로 false positive 의 확률은 하나의 1비트의 확률입니다. - 그것은 $1-e^{-km/n}$ 이고 k번 반복하여($(1-e^{-km/n})^k$) 입니다.





## 4.4 Counting Distinct Elements in a Stream

이 섹션에서는 스트림에서 수행 할 수있는 간단한 세 번째 처리 유형을 살펴 봅니다.  
이전 예제 (샘플링 및 필터링)와 마찬가지로 합리적인 양의 주 메모리에서 원하는 작업을 수행하는 것은 다소 까다로워서 다양한 해싱과 무작위 알고리즘을 사용하여 스트림 당 필요한 공간을 거의 차지하지 않고 원하는 것을 얻습니다. .

4.4.1 The Count-Distinct Problem

스트림 엘리먼트들이 전체 집합의 일부에서 선택되었다고 가정해봅시다. 우리는 얼마나 많은 엘리먼트들이 스트림에서 나타나는지 알고 싶습니다, 시작스트림부터나 특정 시간부터 세면서

example 4.5



## 4.6 Couting Ones in A Window

우리는 이제 스트림에서 카운팅하는 문제를 봅니다.  
우리가 바이너링 스트림에서의 N 길이의 윈도우를 갖는다고 생각해봅시다.   
우리는 모든 시간에 쿼리에 대답할 수 있기를 원합니다. '최근 k 비트 중 몇개의 1 이 있었는지' (k<N)  
이전 세션에서는, 우리가 전체 윈도우를 저장하지 못하는 상황을 다뤘습니다.  
바이너리 상황에 대한 추정 알고리즘을 보여준 후,  
우리는 어떻게 이 아이디어를 숫자를 더하는 것으로 확장하는지에 대해 이야기합니다. 

### 4.6.1 The Cost of Exact Counts

최근 k bit 안에서 1의 숫자를 정확하게 샐 수 있기를 원한다고 생각해봅시다.  
그러면 우리는 윈도우의 모든 N 개의 비트를 저장하는 것이 필요하다고 주장할 것입니다. 어더한 representation 으로서, 이는 N보다 더작은 것은 동작하지 못한다고   
증명하자면, 우리가 N 보다 작은 표상이 있다고 생각해봅시다.  
2^N 표현보다 더 작지만  N 비트의 2^N 시퀀스가 있기 때문에, 표상이 같지만 다른 비트열 w, x 가 반드시 있습니다.  w가 x 는 아니기 때문에, 그것들은 적어도 하나의 비트는 다를 것 입니다.  
w 와 x 의 최근 k-1 가 동일하다고 두었다면, 그것들의 k번째 비트는 다르게 두어야 합니다.(오른쪽 끝에서 부터)

#### example 4.10

w = 0101 , x = 1010  이면 k=1 이다. 오른쪽에서부터 보면 1번 위치에서 다르다.  
w = 1001 , x = 0101 이면, k=3 이다. 오른쪽부터 3번째 위치에서 다르다. 

윈도우의 내용을 표현하는 데이터는 비트 시퀀스가 w와 x를 모두 나타낸다고 가정해봅시다.  
쿼리 '최근 k 비트에서 1이 몇개가 나왔는지' 를 수행해봅시다.  
Query-answering 알고리즘은 동일한 답을 제공할 것입니다, 그 윈도우가 w나 x를 포함하든지 간에,  
왜냐하면, 그 알고리즘은 오직 그것들의 표상만 볼 수 있기 때문입니다.  
그러나 정확한 답은 확실히 다릅니다. 이 두개의 비트열과는  
그래서 우리는 증명합니다. 우리가 적어도 N개의 비트를 사용해야한다고(최근 k에 대한 쿼리를 하기 위해서는)

결국, 우리는 N 비트가 필요합니다. 우리가 물을 수 있는 쿼리가 N길이의 전체 원도우에서 1이 몇개 있는지에 대해 질문을 할지라도  
이 논리도 위의것과 유사합니다.  
우리가 N보다 적은 비트를 윈도우를 표현하기 위해 사용한다고 생각해봅시다. 그래서 우리는 w와 x 그리고 k 를 위와같이 찾을 수 있습니다.  
w와 x 가 1의 같은 숫자를 갖는다면, 4.10 과 같은.  
그러나 만약 현재 윈도우를 N-k비트 까지 있었고, 우리가  

### 4.6.2 DGIM 알고리즘

이 알고리즘은 N 비트의 윈도우를 표현하는 O(log^2N) 비트 를 사용하는 알고리즘입니다.  
이것은 윈도우에서 1의 숫자를 추정하고 에러는 50%를 넘지 않습니다.  
나중에 향상된 버전에서 동일한 비트를 사용해서 에러를 상수비율로 줄일 수 있습니다.  

스트림의 각 비트들은 타임스템프를 갖습니다. 이것은 그것이 도착한 시간입니다.  
첫번째는 1 두번째는 2 와 같은 식으로 수행합니다.  
우리는 오직 N길이의 윈도우 안에서 위치를 구분해는 것만 필요하기 때문에 우리는 mod N 의 타임스템프를 표현합니다 그래서 그것들은 $log_2N$ 비트로 표현될 수 있습니다.  
만약 우리가 스트림에서 봤던 비트의 전체 수 mod N 을 저장한다면, 현재 창에서 해당 타임 스탬프가있는 비트가있는 타임 스탬프 모듈로 N을 결정할 수 있습니다.  

윈도우를 버킷들로 나눌 수 있습니다.  

1. 오른쪽 끝(최근) 의 타임스템프
2. 버킷의 1의 수,  
   이 숫자는 2의 power 가 되어야 합니다.  
   그리고 우리는 1의 수를 버킷의 **사이즈** 라고 합니다.

버킷을 표현하기 위해, 우리는 log_2N 비트가 필요합니다. 

@@

- 오른쪽 끝의 버킷은 항상 1을 가진 위치이다.
- 모든 1을 가진 위치는 특정 버킷에 있다.
- 한 위치에서 2개 이상 버킷을 갖을 수 없다.
- 어떤 주어진 사이즈에서 특정 최대 사이즈까지의 버켓은 하나 혹은 두개가 있다.
- 모든 사이즈는 파워 2 이다.
- 버킷은 사이즈가 줄어들지 안흔다. 우리가 왼쪽으로 이동하더라도





---

## 4.2 Sampling Data in a Stream

스트림으로 부터 믿을만한 샘플들을 추출하는 것을 봅니다.  다소 특이한 방식으로 해싱을 사용하는 트릭이 있습니다.

### 4.2.1 A Motivating Example

일반적인 문제는 스트림의 부분집합을 선택하는 것입니다.  
그래서 우리는 쿼리를 요청할 수 있습니다. 선택된 부분집합에 대해,  
그리고 전체로서 스트림을 통계적으로 대표하는 답을 할 수 있습니다.  
만약 우리가 요청된 쿼리가 무엇인지 알고 있다면, 수행할 수 있는 많은 방법들이 있습니다.  
그러나 우리는 샘플에서 ad-hoc 쿼리를 할 수 있는 작업을 허용할 수 기술에 대해 살펴볼 것입니다.  
우리는 특정 문제에 대해 살피고 이로부터 일반적인 아이디어를 도출해 냅니다.

예시 : 한 검색 엔진이 쿼리의 스트림을 받습니다. 그리고 그것은 사용자의 일반적인 움직임을 학습하기 원합니다.  
우리는 튜플이 (사용자, 쿼리, 시간) 으로 구성된 스트림이라고 가정합니다.  
우리는 '일반적인 사용자의 쿼리들의 어떤 부분이 지난달에 반복되었나' 에 대한 답을 하길 원합니다.   
우리가 오직 스트림의 1/10 만 저장할 수 있다고 가정해봅시다.  

명확한 접근은 0부터 8까지의 무작위 수들을 발생시켜서 각 쿼리에 대해 받으면 됩니다.  그래서 무작위 수가 0 인 튜플만 저장하면 됩니다.  
우리가 그렇게 하면 평균적으로 1/10 개의 쿼리만 저장됩니다.  
통계적 변동은 데이터안의 노이즈로 될 것이지만, 만약 사용자가 많은 쿼리를 발생시킨다면, 큰수의 법칙이 많은 사용자들이 1/10 의 저장된 쿼리와 많이 가까워진다는 것을 확신할 수 있습니다.

그러나 이런 방식은 우리에게 잘못된 답을 줍니다. 사용자에 대해 중복된 쿼리의 평균 숫자를 묻는 쿼리에게 대해서  
사용자가 s 검색 쿼리를 지난 한달동안 한번 수행하고, d 검색 쿼리를 2번, 3번 이상의 쿼리는 없었다고 가정해 봅시다.   
1/10 번째 샘플 쿼리가있는 경우 해당 사용자의 샘플에서 한 번만 실행 된 검색 쿼리의 s / 10을 볼 수 있습니다.  
두 번 발행 된 d 검색 쿼리 중에서 샘플에는 d / 100 만 두 번 나타납니다.  
이 분수는 쿼리의 두 발생이 모두 1/10 샘플에있을 확률의 d 배입니다.  
 전체 스트림에서 두 번 나타나는 쿼리 중 18d / 100이 정확히 한 번 나타납니다.  
이유를 확인하려면 18/100은 두 발생 중 하나가 선택한 스트림의 1/10에있을 가능성이고 다른 하나는 선택되지 않은 9/10에있을 확률입니다.

s가 샘플에 있을 확률은 1/10 이고

d 가 샘플에 있을 확률은 

전체 스트림의 1/10 만 샘플링 할 수 있는 경우, 샘플링을   
1/10 의 스트림 안에 두번 나타난 쿼리 중 정확히 18d/100 이 한번 나타납니다.@@







---

그리고 블록의 요약은 단순히 그 블록에있는 것의 수 마지막 k 비트에 대한 1의 수를 알고 싶을 때 마지막 k 비트 내에 완전히 존재하는 일부 블록은 카운트를 더합니다.

그것은 마지막 블록 일뿐입니다.

우리는 마지막 k 비트 내에서 얼마나 많은 것들을 알지 못하므로 추측해야합니다.

하지만 기하 급수적으로 증가하는 블록을 만들면 모든 시간 단위는 비트 수만큼 길이가 1 인 블록이 많을 것입니다.

블록, 크기 2, 4, 8 등을 포함하여 창.

그래서 그것은 우리에게 아무것도 저장하지 않습니다.

대신 왼쪽 끝, 즉 끝인 경우 블록을 삭제해야합니다.

가장 빠른 시간에 더 큰 블록의 왼쪽 끝과 일치합니다.

오른쪽에 더 큰 블록이 있으면 나중에 스트림에서 작은 블록을 삭제합니다.

결과적으로 어떤 크기의 블록도 두 개 이상 가질 수 없습니다.

여기에 우리가 보유하고있는 블록의 예가 있습니다.

5 행의 블록 길이는 1, 2, 4, 8, 16입니다.

자, 길이 1의 두 블록이 있습니다.

가장 최근의 숫자는 단일 0으로 구성되므로 0입니다.

그게 다야 다른 하나는 1로 구성되므로 1의 수를 갖습니다.

'케이? 길이가 2 인 블록이 있습니다.

0을 나타 내기 때문에 1의 카운트를 갖습니다.

즉,이 두 비트입니다.

우리는 이전에 d.

길이가 1 인 블록은 그 위에있는 길이 2의 블록과 같은 지점에서 시작하기 때문에 여기로 이동합니다.

또한 길이가 1 인 다른 모든 블록은 길이 2의 블록이 완전히 오른쪽에 있습니다.

우리는 또한 길이 2의 두 번째 블록을 보여줍니다.

이 숫자는 1을 나타내므로 2입니다.

길이 4의 두 블록이 있으며 2와 3의 수를가집니다.

그들은이 녀석이이 순서를 나타냅니다. 0 0 1 1이므로 두 개의 1이 있습니다.

이것은 1,011을 나타내고 따라서 3을 얻습니다.

'케이.

우리는 길이가 8 인 블록 하나를 봅니다.

개수는 4입니다.

이 8 비트를 나타 내기 때문에 보자.

그리고 길이 8의 두 번째 블록에 대한 카운트는 6 개가 있다는 것을 알 수 있기 때문에 그것은 tad이므로, 그 6은 길이가 16 인 블록과 길이가 8 인 블록.

또는 10 빼기 4는 6과 같습니다.

따라서이 블록이 존재했다면 반드시 6 번을 가질 것입니다.

괜찮아.

이제 가장 최근 28 비트에 몇 개가 있는지에 대한 쿼리가 있다고 가정합니다.

특정 블록의 수를 합산 할 수 있습니다.

오른쪽 끝에 약간의 작은 블록이 있고 왼쪽에 더 큰 블록이 있습니다.

우리는 블록을 선택하여 가장 최근의 28 비트 각각이 우리가 선택한 블록 중 하나입니다.

그래서 우리는 길이가 1 인이 블록을 선택합니다.

이 블록의 길이는 2입니다.

이것은 길이 4입니다.

우리는이 길이의 블록을 원하지 않기 때문에이 길이의 블록을 원하지 않습니다 16 그리고 그것은 여전히 ​​지난 28 년 안에 있습니다.

지금까지 23 비트를 다루었 고 우리는 그들 중에서 1은 0 더하기 1 더하기 2 더하기 10입니다. 13입니다. 그래도 가장 오래된 5 비트는 어떻게해야합니까? 우리는 우리가 알고있는 비트를 볼 수 있다면이 비트가 있습니다.

그것들은 0 0 1 0 1이므로 두 개의 1을 가지지 만 우리는 그것들을 보지 못합니다.

우리가 볼 수있는 것은 그것들이 16의이 블록의 일부라는 것입니다.

우리는 블록의 개수가 6 개라는 것을 알고 있습니다. 그러나 가장 최근 5 개 위치에 6 개 중 몇 개가 있는지 알 수 없습니다.

다시, 우리는 더 이상 이것을 보지 못합니다.

물론 우리가 그들을 볼 수 있다면 정답은 15입니다.

그러나 우리는이 지역에 얼마나 많은 사람들이 있는지 보지 않고 추정해야합니다.

이 경우 3,6을 2로 나눈 블록의 절반이 지역에 있다고 생각하면 우리는 보지 못하고 16을 추측 할 것입니다.

그것은 단지 7 % 만 떨어져 있어도 나쁘지 않습니다.

우리는 심지어 비례적인 추측을 시도 할 수 있습니다. 우리는 6을 16으로 나눈 6, 6을 16으로 나눈 것은 주어진 비트 일 확률입니다.

이 블록의 16으로 표시되는 범위에서 1이고 5를 세어야한다는 것을 알고 있습니다.

30을 16으로 나눈 값은 대략 2입니다. 따라서 2를 추측하고 추가하면 15가됩니다.

그리고 우리가 그 숫자를 세고 싶었던 5 비트를 보지 못했지만 마크에 맞습니다.

이 전략에는 추천 할 것이 많습니다.

자, 먼저 로그 N 비트의 제곱 만 저장합니다.

우리는 log를 사용한다고 언급 할 수 있습니다. 우리는이 표현을 사용합니다 (log2N) N의 제곱을 의미합니다.

이것은 일반적인 표현입니다.

로그 N 제곱으로 작성하고 싶지 않습니다. 왜냐하면 실제로는 2 2 log N이기 때문입니다.

다시 한번,이 표기법을 본 적이 없다면 통나무 위의 사각형은 실제로 모든 것을 제곱하고 있음을 의미합니다.

제곱 로그 N.

알았어, 지금 내가 말했듯이, 정사각형, 로그 N 비트의 정사각형을 저장하는 것은 그렇게 나쁘지 않습니다.

큰 N의 경우 N보다 훨씬 적습니다.

따라서 N이 10 억이면 로그 제곱 N은 약 900입니다.

이제 왜 우리는 N 제곱 N 비트의 순서로만 필요한가? 우선, 창 크기가 N 비트이면 길이가 N보다 큰 블록이 필요하지 않습니다.

최대 n 개의 계정을 N 비트 중 2 비트에 로그에 저장할 수 있습니다.

이제 몇 개의 카운트가 필요합니까? 글쎄, 1 1에서 4, 8, 16 등의 로그 기반 2 N 박스 크기 만 있습니다.

길고 큰 2의 최대 거듭 제곱.

n N.

따라서 어떤 크기의 블록도 두 개 이상 저장하지 않습니다.

결과적으로, 우리는 최대 2 개의 로그 N 카운트, 최대 2 개의 로그 비트를 저장해야하며, 이는 2 개의 로그 제곱 N입니다.

또 다른 좋은 점은 각 비트마다 제한된 양의 작업을 수행한다는 것입니다.

길이가 1 인 새 블록을 만들어야합니다.

각 길이 1, 2, 4, 8 등.

우리는 그 길이의 블록을 떨어 뜨리거나 두 블록을 결합해야 할 수도 있습니다 하나의 길이는 다음 큰 길이의 두 블록으로.

그러나 이는 로그 N 크기가 있으므로 대부분의 주문 로그 N이 합계임을 의미합니다.

그리고 오류는 종종 작습니다.

가장 큰 블록 수보다 클 수 없습니다.

우리가 세는 지역에 부분적으로 만있는 것입니다.

그러나 구성표에 문제가 있습니다.

1이 스트림의 모든 영역에 균등하게 분배되면 모호한 영역의 1은 우리가 계산하고자하는 지역에서 1의 총 수의 절반 이상을 차지합니다.

따라서 우리의 오류는 50 %로 제한되지만 모든 오류가 우리가 계산하려는 영역은 왼쪽 끝에 있으며, 특히 원하는 영역 내에 부분적으로있는 블록 만 계산합니다.

그런 다음 실제 개수는 0에서 해당 블록의 전체 개수까지 될 수 있습니다.

우리가 추측하는 것은 잘못 될 수 있으며 결코 알 수 없습니다.

따라서 우리는 좋은 것을 유지하고 유사한 알고리즘을 논의 할 것입니다.

1의 고르지 않은 분포 문제를 피합니다.

우리는 여전히 창을 블록으로 나누지 만 각 블록을 덮지 않고 문자열의 고정 세그먼트 인 경우 각 블록에 고정 된 숫자 1을가집니다.

블록의 크기는 여전히 2의 거듭 제곱으로 제한됩니다.

1, 2, 4, 8 등이지만 블록 크기의 개념이 변경됩니다.

이제 블록의 크기는 1의 숫자입니다.

세그먼트를 나타내는 크기가 1 인 블록이 있습니다.

단일 1을 갖는 스트림 두 배의 크기를 가진 블록은 두 개의 1과 0의 수를 나타냅니다.

그리고 네 개의 1과 0의 숫자 등을 나타내는 블록이 있습니다.

이 체계의 장점은 재전송 스트림에 1이 거의 없으며 해당 영역을 덮는 블록 크기는 작게 유지된다는 것입니다.

크기가 큰 스트림의 큰 부분을 덮거나 1의 수는 제한되어 있습니다.

DGIM 알고리즘을 설명 할 알고리즘을 호출하기로 결정했습니다.

이니셜은이 알고리즘 Mayur Datar, Aristides Gionis, Piotr Indyk 및 Rajeev Motwani를 발명 한 4 명을 말합니다.

사실, 지금은 그만두고 좋은 시간입니다.

이 알고리즘이 출판 된 직후에 죽은 Rajeev Motwani를 기억하십시오.

그는 Gionis 및 Indyk와 함께 이 과정의 주요 부분을 구성하는 지역 민감성 해싱.

이전의 시도 및 알고리즘과 마찬가지로 DGIM은 (log2N) 비트 순서로 저장하여 1N 비트 윈도우를 나타냅니다.

모든 쿼리에 대한 응답에서 50 % 이하의 오류가 절대적으로 보장됩니다.

50 %가 너무 많으면 오류를 0보다 큰 값으로 줄일 수 있습니다.

알고리즘은 필요한 비트 수에서 더 복잡해집니다.

비트 수는 (log2N)에 비례하여 유지되지만 저장소 증가.

그것은 반비례에 비례하여 증가하는 일정한 요인 일뿐입니다 원하는 에러 바운드 이야기를 시작하려면 타임 스탬프에 대한 아이디어를 소개해야합니다.

스트림에 도착하는 모든 비트는 타임 스탬프를받습니다.

우리는 임의의 수의 비트가 필요하다고 생각할 수도 있습니다.

스트림의 길이에 제한이 없으므로 타임 스탬프를 나타냅니다.

그러나 타임 스탬프 모듈로 N, 즉 타임 스탬프를 N으로 나누고 나머지를 취할 수있는 창 크기 만 나타내면됩니다.

순 효과는 타임 스탬프가 0, 1에서 시작하므로 N에서 1을 뺀 다음 다시 0, 1, 2 등으로갑니다.

윈도우의 스트림 위치에 관계없이 N 비트의 타임 스탬프는 모두 다릅니다.

길이 N의 창을 버킷으로 분할합니다.

각 버킷은 레코드로 표시되며 로그 N 비트 순서로 레코드를 저장할 수 있습니다.

w로.

우리는 윈도우를 나타 내기 위해 로그 N 버킷의 순서로만 필요하므로 로그 제곱 N 비트의 순서로 충분합니다.

기록 내용은 다음과 같습니다.

끝의 타임 스탬프 가장 최근에 도착했습니다.

앞서 언급했듯이 타임 스탬프 모듈로 N을 기록합니다.

타임 스탬프를 나타내려면 log N 비트가 필요합니다.

세그먼트의 시작과 끝 사이의 1의 수입니다.

우리는이 개수를 버킷 크기라고합니다.

그러나 버킷으로 표시되는이 세그먼트에서 1의 수는 2의 거듭 제곱 1의 카운트를 나타 내기 위해 log log N 비트 만 필요한 이유를 설명합니다.

카운트 자체 대신 카운트 로그를 저장할 수 있기 때문에 카운트에 대한 로그베이스는 정수 여야한다는 것을 알고 있습니다.

카운트 자체는 N보다 높을 수 없으므로 대수는 N의 log base 2보다 높을 수 없습니다.

대수는 정수 r i이므로 이진으로 i를 나타내려면 log i 비트 만 필요합니다. log log N 비트이면 충분합니다.

우리는 여전히 주문 로그 N이 필요하기 때문에별로 중요하지 않습니다.

버킷의 레코드에 비트를 추가하여 끝의 타임 스탬프를 저장합니다.

버킷으로 파티션은 다음 규칙을 따라야합니다.

하나 또는 우리가 필요로하는 최대 크기까지 허용되는 각 측면의 2 개의 버킷.

허용되는 크기는 2의 거듭 제곱입니다.

윈도우의 비트는 두 버킷의 일부가 아닙니다.

스트림의 일부 0은 버킷에 속하지 않을 수 있습니다.

그것은 중요하지 않습니다.

그러나 시간이 지남에 따라 버킷 크기는 증가 할 수 있습니다.

창의 가장 최근 부분은 가장 작은 버킷으로 표시됩니다.

버킷의 종료 타임 스탬프가 과거의 종료 시간 단위보다 크면 더 이상 창의 일부를 나타내지 않으므로 레코드가 저장된 버킷 세트에서 삭제합니다.

다음은 버킷으로의 스트림 파티션의 모습을 보여줍니다.

어떤 점에서.

가장 최근의 2 개의 1은 그 자체로 크기가 1 인 버킷에 있으며 여기와 여기에 있습니다.

또한, 이전의 2 개의 1은 크기가 2 인 버킷으로 그룹화됩니다.

크기가 2 인 버킷이 두 개있을 수 있지만 이 경우와 같이 하나만있을 수도 있습니다.

시간을 거슬러 올라가서 우리는 이전 4 개의 1을 4 크기의 양동이에 넣었고 이전의 4 개의 1도 4 크기의 양동이에 있습니다.

그런 다음 크기가 8 인 두 개의 버킷이 보입니다.

그리고 마지막으로 16 사이즈의 버킷.

이 버킷의 종료 타임 스탬프는 여전히 길이 N의 창 내에 있습니다.

그게 다야 시작은 창 밖에 있지만.

여전히이 버킷이 필요하지만 이전 버킷에는 타임 스탬프가 현재 창을 시작하기 전에 레코드를 삭제했습니다.

비트가 스트림에 도착할 때 버킷을 관리하는 방법을 살펴 보겠습니다.

우리가 가장 먼저 할 일은 가장 오래된 버킷을 떨어 뜨려야하는지 걱정이됩니다.

화면에 도착한 비트 수의 개수 인 버킷 표현을 벗어나야합니다.

그러나이 카운트 모듈로 N 만 필요하므로 여분의 로그 단위 비트 만 있으면됩니다.

새로운 비트가 들어 오면 해당 카운트를 증가시킵니다.

물론 카운트가 N에 도달하면 다시 0으로 설정합니다.

이것이 모듈 식 산술이 작동하는 방식입니다.

이제 가장 오래된 버킷의 종료 시간을보십시오.

타임 스탬프가 현재 시간과 일치하면 해당 타임 스탬프는 모든 타임 스탬프 모듈로 N을 계산하기 때문에 실제로 현재 시간에서 N을 뺀 값입니다.

따라서 가장 오래된 버킷 전체가 창 밖으로 나오고 레코드가 삭제됩니다.

그러나 타임 스탬프가 다른 것이라면 가장 오래된 버킷은 여전히 그것은 창 안에서 끝나서 남아 있습니다.

다음에하는 것은 방금 입력 한 비트가 0인지 1인지에 달려 있습니다.

0이면 버킷 집합을 더 이상 변경하지 않습니다.

그것은 쉽다.

현재 입력이 1이면해야 할 일이 있습니다.

그러나 작업은 창 크기 N에서 최대 로그입니다.

먼저 새 비트를위한 새 버킷을 만듭니다.

버킷의 크기는 1이고 종료 타임 스탬프는 현재 시간입니다.

크기가 1 인 버킷이 한두 개있을 수 있습니다.

하나만 있으면 이제 두 개가 있고 괜찮습니다.

우리는.

어떤 크기의 한두 가지를 가지고 있었다.

그러나 이전에 두 개가 있다면 지금 세 개가 있습니다.

크기가 1 인 3 개의 버킷을 가질 수 없으므로 우리는 가장 오래된 2 개를 크기가 2 인 버킷 하나로 결합합니다 동일한 크기의 연속 버킷을 쉽게 결합 할 수 있습니다.

크기의 로그에 1을 더하고 우리는 N 타임 스탬프를 가장 최근의 N 타임 스탬프로 사용합니다.

예를 들어, 여기에 두 개의 버킷이있을 수 있습니다. 어떤 크기의 연속 버킷이든, 2를 x로 가정하겠습니다.

우리는 그것들을 크기 2에서 x + 1의 하나의 버킷으로 결합합니다. 간단히 말해서이 버킷은이 종료 시간을 얻습니다.

나는 단지 여기에서 그것을 복사합니다.

그리고 크기에 1을 더합니다. 따라서 기본적으로 크기가 두 배로 늘어난 다음 사라지게 만듭니다.

그러나 우리의 일은 끝나지 않았을 것입니다.

크기 2의 버킷을 만들어야한다면 이제 그 크기 중 3 개를 가질 수 있습니다.

따라서 우리는 가장 빠른 2 개를 크기가 4 인 하나의 버킷으로 결합합니다.

그리고 문제는 크기에 영향을 줄 수 있습니다.

방금 크기가 4 인 세 번째 버킷을 만든 경우 크기 4.

가장 빠른 2 개를 8 개 크기의 버킷으로 결합해야합니다.

하지만 문제를 전달할 때마다 버킷 크기를 두 배로 늘리기 때문에 다음 단계에서는 log N 수정이 완료된 후 버킷 크기에 도달했습니다.

전체 창과 더 큰 버킷이 필요하지 않습니다.

'케이.

따라서 리플 링 효과는 최대 N 로그 라운드 후에 멈 춥니 다.

그리고 각 라운드는 일정한 양의 작업이 필요할 수 있습니다.

따라서 O (logN)는 필요한 총 시간에서 상한을 보장합니다.

수신 처리 일반적으로 필요한 시간은 훨씬 적으며 평균적으로 일정합니다.

이 슬라이드에서는 비트가 시스템에 입력 될 때 발생하는 변경 사항을 확인할 수 있습니다.

창의 초기 상태는 다음과 같습니다.

A 1이 들어갑니다.

이를 위해 크기가 1 인 버킷을 만듭니다.

그러나 이제 크기가 1 인 3 개의 버킷이 있습니다.

그래서 우리는 가장 빠른 2 개의 1을 결합해야합니다.

이 하나.

그리고 저것.

자, 여기 조합을 완료했습니다.

기록의 관점에서 일어난 것은 이 버킷이 삭제되었습니다.

이 레코드의 크기가 1에서 2로 변경되었습니다.

타임 스탬프는 변경되지 않았으므로 실제로이 레코드가되었습니다.

그리고 1은 실제로이 슬라이드가 완벽하게 표시되지 않았다는 기록에 있습니다.

이제 또 다른 101 명이 도착한 후 어떻게되는지 보여주고 있습니다.

괜찮아? 이 중 첫 번째는 이것을 만들었습니다.

그리고 0은 아무것도 바뀌지 않았 음을 나타냅니다.

그리고이 다음 1이 도착합니다.

이제 크기가 1 인 세 번째 버킷이 생깁니다.

자, 그러면이 두 버킷이이 사람과 결합됩니다.

이제 크기가 2 인 3 개의 버킷이 있습니다.

그래서 우리는이 둘을 하나가 실제로 속하는 것으로 결합해야합니다 크기 2의 중간 버킷에 들어갑니다.

따라서이 두 가지를 버킷 크기 4로 결합합니다.

그리고 크기가 4 인 버킷 3 개를 만들었습니다.

8 번 버킷, 8 번 버킷 중 세 번째 버킷이었습니다.

크기가 8 인 버킷은 해당 버킷 크기 16에 결합되었습니다.

이제 크기가 16 인 버킷을 더 이상 사용할 수 없습니다.

이 것이 있지만 창 끝을 넘어 확장됩니다.

이제 우리는 더 큰 버킷과 더 큰 버킷으로 변화를 가져 왔습니다.

이제 시스템을 쿼리하는 방법을 설명하고 싶습니다.

마지막 k에 몇 개의 1이 있는지 알고 싶다고 가정 해 봅시다.

여기서 k는 창 크기 N보다 작거나 같은 정수입니다.

먼저 타임 스탬프가 끝나는 모든 버킷을 무시하는 것이 좋습니다 현재 시간 이전에 k 비트보다 빠릅니다.

그 물통은 모두 우리가 계산하고 싶은 범위 밖에 있습니다 그들은 기여하지 않습니다.

가장 오래된 버킷을 제외한 모든 버킷의 크기를 합산하여 시작하십시오.

여전히 우리가 관심있는 범위에 있습니다.

그런 다음 해당 버킷 크기의 절반을 추가하십시오.

괜찮아.

우리가 가장 오래된 버킷 크기의 절반 밖에 안한 이유는 우리가 실제로 알지 못하기 때문입니다 그 버킷에서 몇 개가 여전히 관심 범위 내에 있는지 절반을 추측하여 다음 슬라이드에서 설명 할 때 최대 오류를 최소화합니다.

여기에 추정치가 더 많은 t.

정답에서 한 50 %.

우리가 관심있는 범위에서 가장 오래된 버킷의 크기는 2i입니다.

우리는 절반을 가정했다 1의 2i 빼기 1은 가장 최근에 도착한 k 비트 중 하나입니다.

실제 숫자는 1과 2i 사이의 모든 것이 될 수 있으므로 우리의 오류는 2i에서 1을 뺀 값입니다.

이제 정답이 될 수있는 가장 작은 것은 무엇입니까? 각 크기의 버킷이 하나 이상 있습니다.

마지막 k 비트 내에 완전히있는 2i.

이들은 적어도 1 더하기 2를 설명합니다 더하기 4 더하기 등, 최대 2i 빼기 1 그리고 그것은 2입니다. 그 합은 2i 빼기 1입니다.

이제 가장 오래된 버킷 끝에있는 1에 1을 추가합니다.

해당 버킷에는 범위 내에있는 종료 타임 스탬프가 있습니다.

버킷은 항상 1로 끝나므로 범위 내에 적어도 2i 1이 존재한다.

우리의 오류는 2i에서 1을 뺀 값이므로 그 오류는 최대 50 %입니다.

우리는 여기서 확장에 대해 논의하지 않을 것이지만 오류를 제한하기 위해 설명 된 알고리즘을 수정할 수 있습니다 우리가 0보다 큰 분수는 여전히 우리가 나타내야 할 모든 버킷을 나타 내기 위해 제곱 된 N 비트를 기록합니다.

교과서는이를 수행하는 방법을 설명합니다..

