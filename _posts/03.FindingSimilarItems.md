## Finding Similar Items

기본적인 데이터 마이닝 문제는 유사한 아이템에 대한 데이터를 검사하는 것입니다. 3.1에서 활용을 보여줍니다. 예시는 웹페이지 모음이나 복제된 페이지들을 찾는 것입니다. 이러한 페이지들은 표절이 될수도 있고 호스트 정보가 다르고 동일한 내용이 다른 미러가 될 수 있습니다. 

유사한 아이템 쌍을 찾는 단순한 방식은 모든 아이템 쌍을 다 찾아보는 것입니다. 대규모 데이터셋을 다룰 때 모든 데이터 셋을 찾는 것은 좋은 하드웨어를 갖고있더라도 제한적입니다. 예를 들어 백만의 아이템셋이 주어진다해도 조 단위의 쌍을 검사해야합니다. 그리고 백만의 아이템셋도 요즘 기준에는 작은축에 속합니다.

locality-sensitive hasing, LSH 는 모든 쌍을 다 보지 않고도 유사할 것 같은 쌍을 파악할 수 있도록 하는 기술이 있습니다. 이것은 기존 알고리즘의 쿼드라틱 계산시간을 피할 수 있게합니다. false negative 가 있기 때문에 LSH 의 단점은 항상 존재하긴합니다. - 검사한 쌍의 집합에 포함하되진 않지만 유사한 아이템의 쌍. 그러나 잘 조정하면 우리가 고려한 페어의 수를 높이면서 이러한 false negative를 줄일 수 있습니다. 

LSH의 기본 아이디어는 아이탬을 많은 해시 함수들을 사용하여 해시하는 것입니다. 이 해시함수들은 기존의 해쉬함수들을 나열한 것이 아닙니다. 대신 아이템끼리 유사할 수록 동일한 bucket 에 담기도록 속성을 잘 설계하는 것입니다. 그러고 나서 몇개의 후보쌍만 검사하면 됩니다. 적어도 하나 이상의 해시 함수들에서 동일한 버캣에 있는 아이템의 쌍만 검사하면 됩니다. 

공통 텍스트가 얼마나 있는지를 기준으로 유사한 문서를 찾는 문제를 가지고 LSH 에 대해 설명을 할 것입니다. 우선 문서를 집합으로 어떻게 표현하는지 보입니다. 문서의 문자적인(textual) 유사성을 많이 겹치는 집합으로 보는 방식을 사용합니다. jaccard 유사도로 집합의 유사성을 측정하는 것입니다. intersection과 union의 크기 비율을 사용합니다. 두번째로 minhashing 를 다룹니다. 이는 큰 셋을 더 작은 signature 라고 불리는 representation 으로 변환하는 방법입니다. 이 또한 jaccard 유사도를 사용하여 represented 집합을 추정할 수 있습니다. 마지막으로 3.4에서 signature에 LSH에 내재한 버켓팅 아이디어를 적용하는지에 대해 살핍니다. 



## 3.1 Applications of Set Simliarity

유사도의 특정 개념에 포커스를 맞춰봅시다. : 집합의 유사도, 그것들의 교집합의 상대적인 크기를 사용한. 이 유사도 개념은 jaccard 유사도라고 불립니다. 3.1.1 에서 다룹니다. 그러고 나서 유사한 집합을 찾는 것의 몇가지 용도를 들어 봅니다. 이것은 문자적으로 유사한 문서를 찾는 것을 포함하고 우사한 고객과 상품을 찾는 collaborative filtering 을 포함합니다. 문서의 문자 유사도 문제를 교집합의 하나로 바꾸기 위해 shingling 이라고 불리는 기술을 사용합니다. 이는 3.2에서 다룹니다. 



### 3.1.1 Jaccard Similarity of Sets

집합 S 와 T의 자카드 유사도는 $|S \cap T| / |S\cup T|$ 입니다. 합집합의 크기 분에 교집합의 크기 입니다. 이를 $SIM(S,T)$ 로 표기합니다. 



### 3.1.2 Similarity of Documnents

자카드 유사도가 잘 다루는 문제들의 중요한 클래스는 웹이나 신문기사와 같은 큰 코퍼스 내에서 문자적으로(texually) 유사한 문서를 찾는 것입니다. 우리가 여기서 보는 유사도의 양상은 문자 단위 유사도이며, 유사한 의미가 아닙니다. 이러한 문제 또한 흥미롭니다. 다른 기술로 다루는 문제입니다. 문자적 유사도를 다루는 문제는 복제본이나 유사 복제본을 찾는 것과 관련이 있습니다. 두 개의 문서가 완전히 복제된 것을 검사하는 작업은 쉽습니다. 문자 간 비교만 하면 됩니다. 그러나 실제 많은 상황에서 문서들은 동일하지 않지만 텍스트를 많은 부분 공유하지 합니다.

#### Plagiarism

표절된 문서를 찾는것은 문자적 유사도를 찾는 능력을 검증합니다. 표절자는 문서의 일부분만 뽑아서 쓸 것이고 몇개의 단어와 일부 순서를 바꿀 것입니다. 그래도 결과에는 원본에 많은 부분이 포함되 있을 것입니다.봅잡한 표절을 감지하는 문자와 문자만 비교하는 단순한 처리방식은 없을 것 입니다.



#### Mirror Pages

유면한 웹사이트는 많은 호스트로 복제되는 것은 일반적입니다. (로드 분배를 위한) 이러한 미러 사이트 페이지는 꽤 비슷하지만 거의 동일한 것은 아닙니다. 예를들어 각 사이트들이 그것들의 특정 호스트와 관련된 정보를 포함할 수 있고, 다른 미러 사이트들로 링크를 갖지만 그 자신에 대한 링크는 안갖는 경우도 있습니다. 관련된 예시로는 하나의 아카데미 클래스로부터 다른 곳으로 가는 웹페이지를 재사용하는 것입니다. 이러한 페이지들은 클래스 노트, 과제, 슬라이드등을 포함합니다. 유사 페이지는 코스의 이름, 년도 등 일부가 바뀔것입니다. 이러한 종류의 유사한 페이지를 갑지할 수 있는 것은 중요합니다. 검색엔진은 만약 결과물의 첫번째 페이지 안에서 거의 동일한 두개의 페이지를 보여주는 것을 피하고자 한다면 검색 엔진은 더나은 결과를 만들기 위해 중요합니다.



### 3.1.3 Collaborative Filtering as a Simliar-Sets Problem

집합의 유사도가 매우 중요한 실 적용의 또다른 종류는 collaborative filtering 이라 불리는 프로세스입니다. 이는 다른 사용자가 보여준 유사한 취향을 가진 아이템을 추천하는 것입니다. 자세하게는 9.3에서 다루지만 여기서 일반적인 예시를 보이겠습니다.

@@

 

## 3.2 Shingling of Documents

lexically 유사한 문서를 찾기위한 목적으로 문서를 집합으로 표현하기 위한 가장 효과적인 방법은 문서로 부터 그안에 있는 짧은 문자열의 집합을 만드는 섟입니다. 그렇게 하면 구나 문장들의 짧은 조각들을 공유하는 문서들은 그들의 집합에 많은 공통적인 요소를 갖고 있을 것입니다. 문장들이 다른 순서로 나타난다할지라도. 이 섹션에서는 가장 단순하고 일반적인 접근법인 shingling 과 변형에 대해 소개합니다. 



### 3.2.1 K-Shingles

문서는 문자들의 열(String) 입니다. 문서에 대한 K-shingle 은 문서에서 찾은 k길이의 substring 입니다. 그러고 우리는 각 문서를 k-shingle 의 집합과 연결할 수 잇습니다. 문서에 한번이상 나타난

#### example 3.3 

D가 abcdabd 의 경우 k=2 일때 {ab, bc,cd,da,bd} 입니다. 

Substring ab 의 경우 2번 나타나지만 shingle 에서는 한번 표현합니다. 싱글링의 변형에서는 set보다 bag 을 생성해서 각 싱글링이 문서에서 몇번 나타났는지에 대한 결과를 보여줍니다. 여기서는 bag 을 사용하진 않습니다. 



공백을 어떻게 처리할지에 관한 몇가지 옵션이 있습니다. (blank, tab newline ..) 아마 하나 이상의 시퀀스를 단일 블랭크 문자로 대체하는 것이 적당할 것입니다.  둘 이상의 싱글링 과 그렇지 않은 것을 구분합니다. 



#### example 3.4

k=9 를 사용하는 경우 

'The plane was ready for touch down' 과 'the quaterback scored a touchdown' 에서 'touch dow' ㅡ 'touchdown' 이 다르지만 공백을 제거하는 경우 동일하게 touchdown이 될 수 있습니다.



### 3.2.2 Choosing the Shingle Size

어떤 k 도 선택을 할 수 있지만, k 가 너무 작으면 k 문자들의 시퀀스는 대부분의 문서들에서 보일 수 있습니다. 이러면 문장이나 구가 동일한게 없다라도 높은 자카드 유사성을 갖는 문서나 보일 수 있습니다. k=1 인경우를 예를 들어봅시다. 일반적으로 웹페이지들은 대부분의 문자를 갖고 있고 그래서 모든 웹페이지 들이 높은 유사도를 갖게 될 것입니다.

k 의 크기는 일반적으로 문서가 얼마나 큰기와 일반적인 문자의 집합이 얼마나 큰지에 달려있습니다. 

- K 는 어떤 문서에서의 주어진 싱글링이 있을 확률이 충분이 낮은 것으로 선택되어야 합니다. 

문서의 코퍼스가 이메일이면, K는 5 가 괜찮습니다. 이메일에서는 문자와 공백만 나옵니다. 영문 공백 합쳐서 $27^5 = 14,348,907$ 의 가능한 싱글이 있을 수 있습니다. 일반적인 이메일은 14백만 문자보다 작으므로 k=5 가 잘 동작한다고 기대할 수 있고 잘 동작합니다. 

이메일에서는 확실히 27개의 문자보다 더 많지만 모든 문자가 동일한 확률로 나타나지는 않습니다. 일반적인 글자와 공백이 우세한 반면 글자 맞추기에서 "z"와 높은 점수를 갖는 다른 글자는 드뭅니다. 그래서 일반 문자들로 구성된 5-shingle 이 많은 짧은 이메일이여도 위의 식대로 하면 관련없는 이메일일 가능성이 더 높습니다. 큰 문서와 같은 경우 k=9 가 적당합니다. 



### 3.2.3 Hashing Shingles

shingle로서 substring 을 바로 사용하는 것 대신, k 길이의 문자열을 특정 버켓에 매핑시키는 해시 함수를 선택하고 버켓의 수를 shingle 로 다룰 수 있습니다. 문서를 표현한 집합은 문서에서 하나이상의 k-shingle 의 버켓의 숫자의 집합이 될 수 있습니다. 